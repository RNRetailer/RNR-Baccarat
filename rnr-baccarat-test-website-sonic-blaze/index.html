<!DOCTYPE html>
<html>
   <head>
      <meta charset="utf-8">
      <!--[if IE]>
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <![endif]-->
      <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
      <meta name="description" content="">
      <meta name="author" content="">
      <!-- Page title -->
      <title>Sonic Blaze RNR Baccarat Test</title>
      <!--[if lt IE 9]>
      <script src="js/respond.js"></script>
      <![endif]-->
      <!-- Bootstrap Core CSS -->
      <link href="css/bootstrap.css" rel="stylesheet" type="text/css">
      <!-- Icon fonts -->
      <link href="fonts/font-awesome/css/font-awesome.min.css" rel="stylesheet" type="text/css">
      <link href="fonts/flaticons/flaticon.css" rel="stylesheet" type="text/css">
      <link href="fonts/glyphicons/bootstrap-glyphicons.css" rel="stylesheet" type="text/css">
      <!-- Google fonts -->
      <link href="https://fonts.googleapis.com/css?family=Lato:400,800" rel="stylesheet">
      <link href="https://fonts.googleapis.com/css?family=Baloo+Thambi" rel="stylesheet">
      <!-- Style CSS -->
      <link href="css/style.css" rel="stylesheet">
      <!-- Plugins CSS -->
      <link rel="stylesheet" href="css/plugins.css">
      <!-- Color Style CSS -->
      <link href="styles/maincolors.css" rel="stylesheet">
      <!-- Favicons-->
      <link rel="apple-touch-icon" sizes="72x72" href="/apple-icon-72x72.png">
      <link rel="apple-touch-icon" sizes="114x114" href="/apple-icon-114x114.png">
      <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
      <script src="js/wasm_exec.js"></script>
   </head>
   <body id="page-top">
      <!-- Preloader -->
      <div id="preloader">
         <div class="spinner">
            <div class="bounce1"></div>
         </div>
      </div>
      <!-- Preloader ends -->
      <nav class="navbar navbar-custom navbar-fixed-top">
         <div class="container">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
               <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar-brand-centered">
               <i class="fa fa-bars"></i>
               </button>
               <div class="navbar-brand navbar-brand-centered page-scroll">
                  <a href="#page-top">
                     <!-- logo  -->
                     <img src="img/logo.png" class="img-responsive" alt="">
                  </a>
               </div>
            </div>
            <!--/navbar-header -->
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="navbar-brand-centered">
            </div>
            <!-- /.navbar-collapse -->
         </div>
         <!-- /.container -->
      </nav>
      <!-- /navbar ends -->
      <!-- ==== Slider ==== -->
      <div class="container-fluid parallax-header"  
         data-stellar-background-ratio="0.5">
         <div class="container">
            <div class="col-sm-5 text-light text-center bg-darkcolor" data--100-start="margin-top:100px;transform:scale(1)" data--100-top="margin-top:0px;transform:scale(0.7);">
               <h1>Sonic Blaze RNR Baccarat</h1>
               <!--the div below is hidden on small screens  -->
               <div class="hidden-xs">
                  <p class="header-p">
					Play Baccarat
				  </p>
                  <a class="btn btn-primary " href="#admin-panel-index">Go To RNR Baccarat Panel</a>
               </div>
               <!--/d-none  -->
            </div>
         </div>
      </div>
      <!-- /container-fluid -->  
      <!-- SVG Curve Up -->
      <svg id="curveUp" xmlns="http://www.w3.org/2000/svg" version="1.1" width="100%" height="100" viewBox="0 0 100 100" preserveAspectRatio="none" fill="rgba(225, 0, 0, .15)">
         <path d="M0 100 C 20 0 50 0 100 100 Z"/>
      </svg>
      <!-- Section Services-index -->
      <section id="admin-panel-index" class="bg-pattern" data-bottom-top="background-position: 0px 10%,99% 10%;"
         data-top-bottom="background-position: 0px 80%,99% 80%;" style="background-color: rgb(50, 0, 0); background-image: url('./img/casinoPattern.jpg');">
         <!-- container -->
         <div class="container" style="border: 5px solid rgba(255, 0, 0, .2); padding: 25px;">
            <div class="section-heading">
               <div style="color: #53edff; font-size: 60px; font-family:'Baloo Thambi', sans-serif;">-------- Sonic Blaze RNR Baccarat --------</div>

               <div id="connectWalletButtonHolder" class="form-group" style="display:none;">
					   <div class="col-md-6" style="width:100%;margin-top:15px;">
						  <button type="button" onclick="connectWallet()" id="connectWalletButton" name="singlebutton" class="btn btn-primary">Connect Wallet (DO THIS FIRST!)</button>
					   </div>
					</div>

					<div class="col-md-6" style="margin-top:15px;width:100%;">

						<div style="font-size:20px; margin-bottom:20px"><span style="color: #53edff; font-size: 40px; font-family:'Baloo Thambi', sans-serif;">Please select Player or Banker:</span></div>

                 <select id="playerOrBanker" style="width:100%; font-size:20px; text-align:center; background-color:rgba(255,255,255,0.1); color: white;">
                     <option style="background-color:rgb(0,0,0);" value="P" selected="selected">Player</option>
                     <option style="background-color:rgb(0,0,0);" value="B">Banker</option>
                 </select>

                 <img id="loadingGif" width="157.5" height="159.25" style="display:none;" src="https://escrow.monster/images/loading.gif">

					  <button style="margin-top: 20px;" type="button" onclick="play()" id="playButton" name="playButton" class="btn btn-primary">Play a hand of RNR Baccarat</button>
				   </div>
            </div>
            <!-- /section-heading-->
			</div>
	</div>
    <!-- /container-->
	
	</section>
         
      <!-- /footer ends -->
      <!-- Core JavaScript Files -->
      <script src="js/jquery.min.js"></script>
      <script src="js/bootstrap.min.js"></script>
      <!-- Main Js -->
      <script src="js/main.js"></script>
      <!-- Contact form -->
      <script src="js/contact.js"></script>
      <!--Other Plugins -->
      <script src="js/plugins.js"></script>
      <!-- Prefix free CSS -->
      <script src="js/prefixfree.js"></script>
      <!--Mail Chimp validator -->
      <script src='js/mc-validate.js'></script>	  
      <!-- Open street maps-->
      <script src="js/map.js"></script>
	  
	  <script src="https://cdn.jsdelivr.net/npm/web3@latest/dist/web3.min.js"></script>

	  <script>

		const baccaratContractABI = [
	{
		"inputs": [],
		"stateMutability": "nonpayable",
		"type": "constructor"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": false,
				"internalType": "string",
				"name": "handLog",
				"type": "string"
			}
		],
		"name": "HandLog",
		"type": "event"
	},
	{
		"inputs": [],
		"name": "RANDOM_NUMBER_RETAILER",
		"outputs": [
			{
				"internalType": "contract RandomNumberRetailerInterface",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "string",
				"name": "",
				"type": "string"
			}
		],
		"name": "cardValueMapping",
		"outputs": [
			{
				"internalType": "uint8",
				"name": "",
				"type": "uint8"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "deposit",
		"outputs": [],
		"stateMutability": "payable",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "largestBetAllowedInWei",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "ownerAddress",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "bool",
				"name": "userIsPlayer",
				"type": "bool"
			},
			{
				"components": [
					{
						"internalType": "uint256[2]",
						"name": "pk",
						"type": "uint256[2]"
					},
					{
						"internalType": "uint256[2]",
						"name": "gamma",
						"type": "uint256[2]"
					},
					{
						"internalType": "uint256",
						"name": "c",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "s",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "seed",
						"type": "uint256"
					},
					{
						"internalType": "address",
						"name": "uWitness",
						"type": "address"
					},
					{
						"internalType": "uint256[2]",
						"name": "cGammaWitness",
						"type": "uint256[2]"
					},
					{
						"internalType": "uint256[2]",
						"name": "sHashWitness",
						"type": "uint256[2]"
					},
					{
						"internalType": "uint256",
						"name": "zInv",
						"type": "uint256"
					}
				],
				"internalType": "struct RandomNumberRetailerInterface.Proof",
				"name": "proof",
				"type": "tuple"
			},
			{
				"components": [
					{
						"internalType": "uint64",
						"name": "blockNum",
						"type": "uint64"
					},
					{
						"internalType": "uint256",
						"name": "subId",
						"type": "uint256"
					},
					{
						"internalType": "uint32",
						"name": "callbackGasLimit",
						"type": "uint32"
					},
					{
						"internalType": "uint32",
						"name": "numWords",
						"type": "uint32"
					},
					{
						"internalType": "address",
						"name": "sender",
						"type": "address"
					},
					{
						"internalType": "bytes",
						"name": "extraArgs",
						"type": "bytes"
					}
				],
				"internalType": "struct RandomNumberRetailerInterface.RequestCommitment",
				"name": "rc",
				"type": "tuple"
			}
		],
		"name": "play",
		"outputs": [
			{
				"components": [
					{
						"internalType": "string",
						"name": "cardValue",
						"type": "string"
					},
					{
						"internalType": "enum Suit",
						"name": "suit",
						"type": "uint8"
					}
				],
				"internalType": "struct Card[]",
				"name": "playerCards",
				"type": "tuple[]"
			},
			{
				"components": [
					{
						"internalType": "string",
						"name": "cardValue",
						"type": "string"
					},
					{
						"internalType": "enum Suit",
						"name": "suit",
						"type": "uint8"
					}
				],
				"internalType": "struct Card[]",
				"name": "bankerCards",
				"type": "tuple[]"
			},
			{
				"internalType": "enum HandResult",
				"name": "result",
				"type": "uint8"
			}
		],
		"stateMutability": "payable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "newlargestBetAllowedInWei",
				"type": "uint256"
			}
		],
		"name": "setlargestBetAllowedInWei",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "weiToWithdraw",
				"type": "uint256"
			}
		],
		"name": "withdrawETHToOwner",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	}
]; 	


	const abi = [
	{
		"inputs": [],
		"stateMutability": "nonpayable",
		"type": "constructor"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "from",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "address",
				"name": "to",
				"type": "address"
			}
		],
		"name": "OwnershipTransferRequested",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "from",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "address",
				"name": "to",
				"type": "address"
			}
		],
		"name": "OwnershipTransferred",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "uint256",
				"name": "requestId",
				"type": "uint256"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "outputSeed",
				"type": "uint256"
			},
			{
				"indexed": false,
				"internalType": "uint96",
				"name": "payment",
				"type": "uint96"
			},
			{
				"indexed": false,
				"internalType": "bool",
				"name": "success",
				"type": "bool"
			}
		],
		"name": "RandomWordsFulfilled",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "requestor",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "weiPaid",
				"type": "uint256"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "amountOfRandomNumbersReturned",
				"type": "uint256"
			}
		],
		"name": "RandomWordsReturnedSync",
		"type": "event"
	},
	{
		"inputs": [],
		"name": "acceptOwnership",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "contractIsPaused",
		"outputs": [
			{
				"internalType": "bool",
				"name": "",
				"type": "bool"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"components": [
					{
						"internalType": "uint256[2]",
						"name": "pk",
						"type": "uint256[2]"
					},
					{
						"internalType": "uint256[2]",
						"name": "gamma",
						"type": "uint256[2]"
					},
					{
						"internalType": "uint256",
						"name": "c",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "s",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "seed",
						"type": "uint256"
					},
					{
						"internalType": "address",
						"name": "uWitness",
						"type": "address"
					},
					{
						"internalType": "uint256[2]",
						"name": "cGammaWitness",
						"type": "uint256[2]"
					},
					{
						"internalType": "uint256[2]",
						"name": "sHashWitness",
						"type": "uint256[2]"
					},
					{
						"internalType": "uint256",
						"name": "zInv",
						"type": "uint256"
					}
				],
				"internalType": "struct VRF.Proof",
				"name": "proof",
				"type": "tuple"
			},
			{
				"components": [
					{
						"internalType": "uint64",
						"name": "blockNum",
						"type": "uint64"
					},
					{
						"internalType": "uint256",
						"name": "subId",
						"type": "uint256"
					},
					{
						"internalType": "uint32",
						"name": "callbackGasLimit",
						"type": "uint32"
					},
					{
						"internalType": "uint32",
						"name": "numWords",
						"type": "uint32"
					},
					{
						"internalType": "address",
						"name": "sender",
						"type": "address"
					},
					{
						"internalType": "bytes",
						"name": "extraArgs",
						"type": "bytes"
					}
				],
				"internalType": "struct RandomNumberRetailer.RequestCommitment",
				"name": "rc",
				"type": "tuple"
			}
		],
		"name": "fulfillRandomWords",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256[2]",
				"name": "publicKey",
				"type": "uint256[2]"
			}
		],
		"name": "hashOfKey",
		"outputs": [
			{
				"internalType": "bytes32",
				"name": "",
				"type": "bytes32"
			}
		],
		"stateMutability": "pure",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "minimumHealthyLengthOfRandomNumbersArray",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "minimumViablePriceOfARandomNumberInWei",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "mostRecentRequestId",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "owner",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "bool",
				"name": "shouldBePaused",
				"type": "bool"
			}
		],
		"name": "pauseOrUnpauseContract",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "priceMultiplier",
		"outputs": [
			{
				"internalType": "uint8",
				"name": "",
				"type": "uint8"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "priceOfARandomNumberInWei",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "randomNumbersAvailable",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "amountOfRandomNumbersAvailable",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "randomNumbersPerRando",
		"outputs": [
			{
				"internalType": "uint8",
				"name": "",
				"type": "uint8"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "replacementContractAddress",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "amountOfRandomNumbersToRequest",
				"type": "uint256"
			},
			{
				"components": [
					{
						"internalType": "uint256[2]",
						"name": "pk",
						"type": "uint256[2]"
					},
					{
						"internalType": "uint256[2]",
						"name": "gamma",
						"type": "uint256[2]"
					},
					{
						"internalType": "uint256",
						"name": "c",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "s",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "seed",
						"type": "uint256"
					},
					{
						"internalType": "address",
						"name": "uWitness",
						"type": "address"
					},
					{
						"internalType": "uint256[2]",
						"name": "cGammaWitness",
						"type": "uint256[2]"
					},
					{
						"internalType": "uint256[2]",
						"name": "sHashWitness",
						"type": "uint256[2]"
					},
					{
						"internalType": "uint256",
						"name": "zInv",
						"type": "uint256"
					}
				],
				"internalType": "struct VRF.Proof",
				"name": "proof",
				"type": "tuple"
			},
			{
				"components": [
					{
						"internalType": "uint64",
						"name": "blockNum",
						"type": "uint64"
					},
					{
						"internalType": "uint256",
						"name": "subId",
						"type": "uint256"
					},
					{
						"internalType": "uint32",
						"name": "callbackGasLimit",
						"type": "uint32"
					},
					{
						"internalType": "uint32",
						"name": "numWords",
						"type": "uint32"
					},
					{
						"internalType": "address",
						"name": "sender",
						"type": "address"
					},
					{
						"internalType": "bytes",
						"name": "extraArgs",
						"type": "bytes"
					}
				],
				"internalType": "struct RandomNumberRetailer.RequestCommitment",
				"name": "rc",
				"type": "tuple"
			},
			{
				"internalType": "bool",
				"name": "payWithRando",
				"type": "bool"
			}
		],
		"name": "requestRandomNumbersSynchronousUsingVRFv2Seed",
		"outputs": [
			{
				"internalType": "uint256[]",
				"name": "randomNumbersToReturn",
				"type": "uint256[]"
			}
		],
		"stateMutability": "payable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "_amountOfGasUsedForAFulfillRandomNumbersTransaction",
				"type": "uint256"
			}
		],
		"name": "setAmountOfGasUsedForAFulfillRandomNumbersTransaction",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "_maximumCostOfSendInWei",
				"type": "uint256"
			}
		],
		"name": "setMaximumCostOfSendInWei",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint32",
				"name": "_maximumNumbersThatCanBeFulfilledInOneTransaction",
				"type": "uint32"
			}
		],
		"name": "setMaximumNumbersThatCanBeFulfilledInOneTransaction",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "_minimumHealthyLengthOfRandomNumbersArray",
				"type": "uint256"
			}
		],
		"name": "setMinimumHealthyLengthOfRandomNumbersArray",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "_minimumServerBalanceInWei",
				"type": "uint256"
			}
		],
		"name": "setMinimumServerBalanceInWei",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "_minimumViablePriceOfARandomNumberInWei",
				"type": "uint256"
			}
		],
		"name": "setMinimumViablePriceOfARandomNumberInWei",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint8",
				"name": "_priceMultiplier",
				"type": "uint8"
			}
		],
		"name": "setPriceMultiplier",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "_replacementContractAddress",
				"type": "address"
			}
		],
		"name": "setReplacementContractAddress",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "to",
				"type": "address"
			}
		],
		"name": "transferOwnership",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "weiToWithdraw",
				"type": "uint256"
			}
		],
		"name": "withdrawETHToOwner",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	}
]; 

		const rnrContractAddress = '0x91B80393Fd73775f48553e4F54C23EdB114463a0';
		const baccaratContractAddress = '0x50d699931E7aEE0BF6FE7ceaff6e42C4d673fBEA';

		const chainID = 57054;
	  
	    async function connectWallet(){
		  if (window.ethereum) {
			window.ethereumAddresses = await window.ethereum.request({method: 'eth_requestAccounts'});
			window.web3 = new Web3(window.ethereum);
			await switchNetwork(chainID);
			window.rnrContract = new window.web3.eth.Contract(abi, rnrContractAddress);
			window.baccaratContract = new window.web3.eth.Contract(baccaratContractABI, baccaratContractAddress, {handleRevert: true});
			$('#connectWalletButtonHolder').css('display', 'none');
			return true;
		  }
		  alert("Please install MetaMask or Rabby to use this website. Thanks!");
		  return false;
		}
		
		async function switchNetwork(chainId){
			const currentChainId = await web3.eth.getChainId();
			
			if (currentChainId != chainId){
				try {
					await ethereum.request({
						method:'wallet_switchEthereumChain',
						params: [{chainId: Web3.utils.toHex(chainId)}]
					});
					console.log(`switched to chainid : ${chainId} succesfully`);
					return true;
				}catch(err){
					console.log(`error occured while switching chain to chainId ${chainId}, err: ${err.message} code: ${err.code}`);
					return false;
				}
			}
			else{
			    return true;
			}
                }
		
		window.onload = (event) => {
		    isConnected();
		}

		function sleep(ms) {
			return new Promise(resolve => setTimeout(resolve, ms));
		}
		
		async function metamaskAccountsExist(){
			if (window.ethereum){
				const accounts = await window.ethereum.request({method: 'eth_accounts'}); 

				if (accounts.length) {
					return true;
				} 
				else {
					return false;
				}
			}
			else {
				return false;
			}
		}
            
	    async function isConnected() {
			const doAccountsExist = await metamaskAccountsExist();
		
		    if (doAccountsExist){
				console.log(`You're connected to MetaMask`);
				window.ethereumAddresses = await window.ethereum.request({method: 'eth_requestAccounts'});
			   window.web3 = new Web3(window.ethereum);
				await switchNetwork(chainID);
			   window.rnrContract = new window.web3.eth.Contract(abi, rnrContractAddress);
			   window.baccaratContract = new window.web3.eth.Contract(baccaratContractABI, baccaratContractAddress, {handleRevert: true});
			}
			else {
				$('#connectWalletButtonHolder').css('display', '');
			}
		}
		
		function pullIntFromSecp256k1Part(part){
			const closingBracketIndex = part.indexOf('}');
			const hexString = '0x' + part.substring(0, closingBracketIndex);
			
			return web3.utils.hexToNumber(
			    hexString
			);
		}
		
		function convertSecp256k1To2TupleOfInts(secpString){
		    const parts = secpString.split('{');
			
			return [
				pullIntFromSecp256k1Part(parts[2]),
				pullIntFromSecp256k1Part(parts[3])
			];
		}
		
		async function getRandomNumberFromWASM(metamaskSender, randomSeedArrayLength, latestBlockNumber) {
         showLoadingGif();

			try {
				const block = await web3.eth.getBlock(latestBlockNumber);
				const blockHash = block.hash;
				const password = 'FJFJDJ37837373@#@#@#@#';
				const subID = 9715;
				const cbsGasLimit = 1000000;
				const numWorkers = 1;
				console.log('About to create a go object')
				const go = new Go();
				console.log('Successfully created a go object')
				const wasmModule = await WebAssembly.instantiateStreaming(fetch("main.wasm"), go.importObject);
				console.log('Successfully instantiated wasm')
				go.run(wasmModule.instance);
				console.log('Successfully ran module instance')

				const result = generate(
							1,
							password,
							metamaskSender,
							subID,
							blockHash,
							latestBlockNumber,
							cbsGasLimit,
							randomSeedArrayLength,
							numWorkers);
							
				const start = result.lastIndexOf('[[');
				const end = result.lastIndexOf(']]');

				if (start === -1 || end === -1) {
					throw new Error("Invalid JSON format in text");
				}

				const JSONString = result.substring(start, end + 2);

				hideLoadingGif();

				return JSON.parse(JSONString)[0];
			} catch (err) {
				hideLoadingGif();
				console.error("Failed to load WASM module or process result:", err);
				throw err;
			}
		}

		function isNum(n){
		    return !isNaN(n);
		}

		function getBetSizeInWei(largestBetAllowedInWei){
		    let betSizeInEth = prompt('How much ETH do you want to bet?');
		    
		    if (betSizeInEth == null){
		        alert('You left the bet size empty. Please try again.');
			     return false;
		    }
		    
		    betSizeInEth = betSizeInEth.trim();
		    
		    if(!isNum(betSizeInEth)){
		    	alert('Invalid bet size. Please try again.');
			   return false;
		    }
		    
		    const betSizeInWei = Web3.utils.toWei(betSizeInEth, "ether");

		    if (betSizeInWei > largestBetAllowedInWei){
		    	const largestBetAllowedInWeiInEth = Web3.utils.fromWei(largestBetAllowedInWei);
		    	alert(`Bet size is larger than the maximum of ${largestBetAllowedInWeiInEth} ETH`);
		    	return false;
		    }

		    return web3.utils.toBigInt(betSizeInWei);
		}

		const loadingGifElement = document.getElementById('loadingGif');

		async function showLoadingGif(){
			loadingGifElement.style.display = '';
      }

      async function hideLoadingGif(){
         loadingGifElement.style.display = 'none';
      }

		async function play(){
			const largestBetAllowedInWei = await window.baccaratContract.methods.largestBetAllowedInWei().call();

			const betSizeInWei = getBetSizeInWei(largestBetAllowedInWei);

			if(betSizeInWei === false){
				return;
			}
						
			const randomSeedArrayLength = 5;
					
			const latestBlockNumber = await web3.eth.getBlockNumber();
			const latestBlockNumberStr = latestBlockNumber.toString();
			
			const metamaskSender = window.ethereumAddresses[0];
			
			const proofAndRequestCommitment = await getRandomNumberFromWASM(metamaskSender, randomSeedArrayLength, latestBlockNumberStr);
			
			// -------------------------------------------------------------------------------------
						
			const pk = convertSecp256k1To2TupleOfInts(proofAndRequestCommitment[10]);
			const gamma = convertSecp256k1To2TupleOfInts(proofAndRequestCommitment[11]);
			const c = web3.utils.toBigInt(proofAndRequestCommitment[12]);
			const s = web3.utils.toBigInt(proofAndRequestCommitment[13]);
			const seed = proofAndRequestCommitment[4];
			const uWitness = proofAndRequestCommitment[16];
			const cGammaWitness = convertSecp256k1To2TupleOfInts(proofAndRequestCommitment[17]);
			const sHashWitness = convertSecp256k1To2TupleOfInts(proofAndRequestCommitment[18]);
			const zInv = web3.utils.toBigInt(proofAndRequestCommitment[19]);
			
			const blockNum = web3.utils.toBigInt(proofAndRequestCommitment[6]);
			const subId = web3.utils.toBigInt(proofAndRequestCommitment[2]);
			const callbackGasLimit = web3.utils.toBigInt(proofAndRequestCommitment[7]);
			const numWords = web3.utils.toBigInt(proofAndRequestCommitment[8]);
			const sender = proofAndRequestCommitment[1];
			
			const debugDict = {
			   pk: pk,
				gamma: gamma,
				c: c,
				s: s,
				seed: seed,
				uWitness: uWitness,
				cGammaWitness: cGammaWitness,
				sHashWitness: sHashWitness,
				zInv: zInv,
				blockNum: blockNum,
				subId: subId,
				callbackGasLimit: callbackGasLimit,
				numWords: numWords,
				sender: sender
			}
			
			console.log(debugDict);
			
			const proof = [
				pk,
				gamma,
				c,
				s,
				seed,
				uWitness,
				cGammaWitness,
				sHashWitness,
				zInv,
			]

			const requestCommitment = [
				blockNum,
				subId,
				callbackGasLimit,
				numWords,
				sender,
				'0x',
			]
			
			const priceOfARandomNumberInWei = await window.rnrContract.methods.priceOfARandomNumberInWei().call();

			const weiToPay = priceOfARandomNumberInWei + betSizeInWei;

			const selectedPlayerBankerValue = document.getElementById('playerOrBanker').value;

			let userIsPlayer = true;

			if (selectedPlayerBankerValue === 'B'){
             userIsPlayer = false;
			}

			web3.eth.handleRevert = true;

			baccaratContract.handleRevert = true;

			async function preflightCheckFunction(fn, params){
			    try {
			      await fn.call(params);
			      return true;
			    } catch (callError) {

			      console.error("Transaction will fail:", callError);

			      if (callError.message) {
			        console.error(
			          "Revert reason:",
			          callError.message
			         )
			      }

			      return false;
			    }
			 }

			//Preflight check
			let preflightCheck = await preflightCheckFunction(
			  window.baccaratContract.methods.play(userIsPlayer, proof, requestCommitment),

			  {
			    from: metamaskSender,
			    value: weiToPay
			  }
			);

			if (preflightCheck === false) {
			   alert("Error processing tx, check console");
			}
			else{
				window.baccaratContract.methods.play(userIsPlayer, proof, requestCommitment).send({
					'from': metamaskSender,
					'handleRevert': true,
					'value': weiToPay
				})
				.on('receipt', function(receipt){
					alert(web3.utils.hexToAscii(receipt['logs'][1]['data'].slice(130)).replaceAll('\x00', ''));
				})
				.on('error', function(error, receipt){
					 console.log(error.message);
				   alert('play failed. Please try again.');
				});
			}
		}

		  

	  </script>
	   
   </body>
</html>
